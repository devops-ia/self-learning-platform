id: "go-02-nil-pointer"
title: "Nil pointer dereference"
briefing: "El programa compila correctamente pero falla en tiempo de ejecucion con un panic. Se accede a un campo de un puntero que es nil porque la clave no existe en el mapa."
prerequisites: []
language: "go"
difficulty: "easy"
initialCode: |
  package main

  import "fmt"

  type Config struct {
  	Host string
  	Port int
  }

  func loadConfig(env string) *Config {
  	configs := map[string]*Config{
  		"prod": {Host: "api.example.com", Port: 443},
  		"dev":  {Host: "localhost", Port: 8080},
  	}
  	return configs[env]
  }

  func main() {
  	config := loadConfig("staging")
  	fmt.Printf("Connecting to %s:%d\n", config.Host, config.Port)
  }

hints:
  - "El mapa `configs` solo tiene claves para `prod` y `dev`. Cuando pides `staging`, Go devuelve el valor cero del tipo, que para un puntero es `nil`."
  - "Antes de acceder a `config.Host` y `config.Port`, necesitas verificar si `config` es nil. Usa `if config == nil` para manejar el caso."
  - "Solucion: despues de `config := loadConfig(\"staging\")`, anade un `if config == nil { ... }` que imprima un error o asigne un config por defecto. Por ejemplo:\n  if config == nil {\n    fmt.Println(\"Error: entorno no encontrado, usando config por defecto\")\n    config = &Config{Host: \"localhost\", Port: 8080}\n  }"
successMessage: |
  !Correcto! El programa maneja el caso nil sin hacer panic.

  Lo que aprendiste:
  - Acceder a un mapa con una clave inexistente devuelve el valor cero del tipo (nil para punteros)
  - Siempre debes verificar si un puntero es nil antes de acceder a sus campos
  - Puedes usar el segundo valor de retorno del mapa: `val, ok := m[key]`
  - Los nil pointer dereferences son uno de los errores mas comunes en Go
  - Es buena practica manejar el caso de error con un valor por defecto o un return early

i18n:
  en:
    title: "Nil pointer dereference"
    briefing: "The program compiles successfully but crashes at runtime with a panic. It accesses a field on a pointer that is nil because the key doesn't exist in the map."
    hints:
      - "The `configs` map only has keys for `prod` and `dev`. When you request `staging`, Go returns the zero value for the type, which for a pointer is `nil`."
      - "Before accessing `config.Host` and `config.Port`, you need to check if `config` is nil. Use `if config == nil` to handle the case."
      - "Solution: after `config := loadConfig(\"staging\")`, add an `if config == nil { ... }` that prints an error or assigns a default config. For example:\n  if config == nil {\n    fmt.Println(\"Error: environment not found, using default config\")\n    config = &Config{Host: \"localhost\", Port: 8080}\n  }"
    successMessage: |
      Correct! The program handles the nil case without panicking.

      What you learned:
      - Accessing a map with a nonexistent key returns the zero value for the type (nil for pointers)
      - You should always check if a pointer is nil before accessing its fields
      - You can use the second return value from a map: `val, ok := m[key]`
      - Nil pointer dereferences are one of the most common errors in Go
      - It's good practice to handle error cases with a default value or an early return

validations:
  - type: syntax
    errorMessage: "El codigo debe contener el paquete main."
    check:
      contains: "package main"
    failMessage: |
      Error: expected 'package', found 'EOF'

      Todo programa Go debe comenzar con `package main`.

  - type: syntax
    errorMessage: "El codigo debe tener una funcion main."
    check:
      contains: "func main()"
    failMessage: |
      Error: runtime.main_main: function main is undeclared in the main package

  - type: semantic
    errorMessage: "Debes verificar si config es nil antes de usarlo."
    check:
      any:
        - match: "config\\s*==\\s*nil"
        - match: "config\\s*!=\\s*nil"
        - match: ",\\s*ok\\s*:=\\s*loadConfig"
        - match: ",\\s*ok\\s*:?=.*configs\\[env\\]"
    failMessage: |
      goroutine 1 [running]:
      main.main()
      	/tmp/main.go:19 +0x26
      panic: runtime error: invalid memory address or nil pointer dereference
      [signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=0x47f426]

      El puntero `config` es nil porque loadConfig("staging") no encuentra esa clave en el mapa. Debes verificar si es nil antes de acceder a sus campos.

  - type: intention
    errorMessage: "Debe haber un manejo del caso nil (mensaje de error, valor por defecto o return)."
    check:
      custom: |
        const hasNilCheck = /config\s*==\s*nil|config\s*!=\s*nil/.test(code);
        if (!hasNilCheck) {
          return {
            passed: false,
            errorMessage: "No se detecta una verificacion de nil. Anade `if config == nil { ... }` para manejar el caso cuando la clave no existe en el mapa."
          };
        }
        const hasHandling = /fmt\.Print|log\.|os\.Exit|return|panic\(|config\s*=\s*&Config/.test(code);
        if (!hasHandling) {
          return {
            passed: false,
            errorMessage: "Tienes la verificacion de nil, pero no manejas el caso. Imprime un error, asigna un valor por defecto o termina el programa."
          };
        }
        return { passed: true };
    failMessage: |
      Necesitas manejar el caso nil: imprimir un error, asignar un config por defecto, o terminar el programa.

terminalCommands:
  "go run main.go":
    - when:
        not_match: "config\\s*[!=]=\\s*nil|,\\s*ok"
      output: |
        goroutine 1 [running]:
        main.main()
        	/tmp/main.go:19 +0x26

        panic: runtime error: invalid memory address or nil pointer dereference
        [signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=0x47f426]

        goroutine 1 [running]:
        main.main()
        	/tmp/main.go:20 +0x1e
        exit status 2
      exitCode: 2

    - output: |
        Connecting to localhost:8080
      exitCode: 0

  "go build":
    - output: |
        Build successful.
      exitCode: 0

  "go vet":
    - output: |
        No issues found.
      exitCode: 0
