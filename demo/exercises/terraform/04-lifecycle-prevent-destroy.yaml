# =============================================================================
# Exercise 4: Lifecycle Conflict (Hard)
# =============================================================================
# Interview scenario: The candidate must understand the conflict between
# prevent_destroy = true and count = 0, and also spot that create_before_destroy
# is incorrectly set to false on the app instance.
# =============================================================================

id: "tf-04-lifecycle-prevent-destroy"
title: "Conflicto de lifecycle: prevent_destroy con count condicional"
briefing: "Esta configuracion tiene dos problemas de lifecycle. El recurso de base de datos tiene prevent_destroy = true pero usa count condicional para eliminarlo (conflicto). Ademas, la instancia de app tiene create_before_destroy = false, que es el valor por defecto y deberia ser true para despliegues sin downtime. Corrige ambos."
prerequisites: []
language: "hcl"
difficulty: "hard"
initialCode: |
  terraform {
    required_providers {
      aws = {
        source  = "hashicorp/aws"
        version = ">= 5.0"
      }
    }
  }

  provider "aws" {
    region = "us-east-1"
  }

  variable "enable_db" {
    type    = bool
    default = false
  }

  resource "aws_db_instance" "main" {
    count = var.enable_db ? 1 : 0

    engine         = "postgres"
    engine_version = "15.4"
    instance_class = "db.t3.micro"
    allocated_storage = 20
    db_name        = "appdb"

    lifecycle {
      prevent_destroy = true
    }
  }

  resource "aws_instance" "app" {
    ami           = "ami-0c55b159cbfafe1f0"
    instance_type = "t2.micro"

    lifecycle {
      create_before_destroy = false
    }
  }
hints:
  - "Hay dos problemas de lifecycle. Uno es un conflicto directo y el otro es una mala practica. Revisa ambos bloques lifecycle."
  - "Si prevent_destroy = true, Terraform rechazara destruir el recurso. Pero con count = 0, Terraform intentara destruirlo. Eso es un conflicto. Y create_before_destroy = false significa que al actualizar la instancia, primero se destruye y luego se crea (hay downtime)."
  - "Cambia prevent_destroy = true a prevent_destroy = false (o elimina la linea) en aws_db_instance, y cambia create_before_destroy = false a create_before_destroy = true en aws_instance."
successMessage: |
  Correcto!

  Lo que aprendiste:
  - prevent_destroy = true impide que Terraform destruya el recurso, incluso con terraform destroy
  - Si usas count para controlar si un recurso existe, prevent_destroy = true crea un conflicto irresoluble
  - create_before_destroy = true crea el nuevo recurso antes de destruir el antiguo (zero-downtime)
  - create_before_destroy = false (por defecto) destruye primero y luego crea, causando downtime
  - En entrevistas avanzadas, entender las interacciones entre meta-argumentos y lifecycle es clave

i18n:
  en:
    title: "Lifecycle Conflict: prevent_destroy with Conditional Count"
    briefing: "This configuration has two lifecycle problems. The database resource has prevent_destroy = true but uses conditional count to remove it (conflict). Also, the app instance has create_before_destroy = false, which is the default and should be true for zero-downtime deployments. Fix both."
    hints:
      - "There are two lifecycle problems. One is a direct conflict and the other is a bad practice. Review both lifecycle blocks."
      - "If prevent_destroy = true, Terraform will refuse to destroy the resource. But with count = 0, Terraform will try to destroy it. That's a conflict. And create_before_destroy = false means when updating the instance, it's destroyed first then created (downtime)."
      - "Change prevent_destroy = true to prevent_destroy = false (or remove the line) on aws_db_instance, and change create_before_destroy = false to create_before_destroy = true on aws_instance."
    successMessage: |
      Correct!

      What you learned:
      - prevent_destroy = true prevents Terraform from destroying the resource, even with terraform destroy
      - If you use count to control whether a resource exists, prevent_destroy = true creates an unresolvable conflict
      - create_before_destroy = true creates the new resource before destroying the old one (zero-downtime)
      - create_before_destroy = false (default) destroys first then creates, causing downtime
      - In advanced interviews, understanding interactions between meta-arguments and lifecycle is key

validations:
  - type: syntax
    errorMessage: "prevent_destroy no debe ser true en aws_db_instance (conflicto con count condicional)."
    check:
      custom: |
        const dbBlock = code.match(/resource\s+"aws_db_instance"\s+"main"\s*\{([\s\S]*?)^\}/m);
        if (!dbBlock) {
          return { passed: false, errorMessage: "No se encontro el recurso aws_db_instance.main." };
        }
        const dbContent = dbBlock[1];
        if (/prevent_destroy\s*=\s*true/.test(dbContent)) {
          return { passed: false, errorMessage: "prevent_destroy = true en aws_db_instance entra en conflicto con count condicional." };
        }
        return { passed: true };
    failMessage: |
      Error: Instance cannot be destroyed

        on main.tf line 22, in resource "aws_db_instance" "main":
        22:   resource "aws_db_instance" "main" {

      Resource aws_db_instance.main[0] has lifecycle.prevent_destroy set, but
      the plan calls for this resource to be destroyed. To avoid this error and
      continue with the plan, either disable lifecycle.prevent_destroy or reduce
      the scope of the change so that aws_db_instance.main[0] is no longer
      included in the list of resources to be destroyed.

      El recurso tiene prevent_destroy = true pero enable_db = false hace que
      count = 0, lo que intenta destruirlo. Es un conflicto irresoluble.
      Cambia prevent_destroy a false o eliminalo.

  - type: semantic
    errorMessage: "create_before_destroy debe ser true en aws_instance para zero-downtime."
    check:
      custom: |
        const appBlock = code.match(/resource\s+"aws_instance"\s+"app"\s*\{([\s\S]*?)^\}/m);
        if (!appBlock) {
          return { passed: false, errorMessage: "No se encontro el recurso aws_instance.app." };
        }
        const appContent = appBlock[1];
        if (/create_before_destroy\s*=\s*false/.test(appContent)) {
          return { passed: false, errorMessage: "create_before_destroy = false causa downtime en actualizaciones." };
        }
        if (!/create_before_destroy\s*=\s*true/.test(appContent)) {
          return { passed: false, errorMessage: "Falta create_before_destroy = true en aws_instance.app." };
        }
        return { passed: true };
    failMessage: |
      Warning: Resource replacement will cause downtime

      The resource aws_instance.app has create_before_destroy = false. When this
      resource needs to be replaced (e.g., AMI change), Terraform will:
        1. Destroy the existing instance
        2. Create the new instance

      This causes downtime between steps 1 and 2. With create_before_destroy = true,
      Terraform creates the replacement first, then destroys the old one.

      Cambia create_before_destroy = false a create_before_destroy = true para
      evitar downtime durante las actualizaciones.

  - type: intention
    errorMessage: "El recurso de base de datos debe mantener el count condicional."
    check:
      custom: |
        const dbBlock = code.match(/resource\s+"aws_db_instance"\s+"main"\s*\{([\s\S]*?)^\}/m);
        if (!dbBlock) {
          return { passed: false, errorMessage: "No se encontro el recurso aws_db_instance.main." };
        }
        if (!/count\s*=\s*var\.enable_db\s*\?\s*1\s*:\s*0/.test(dbBlock[1])) {
          return { passed: false, errorMessage: "No elimines el count condicional de aws_db_instance. El problema es prevent_destroy, no el count." };
        }
        return { passed: true };
    failMessage: |
      No modifiques la expresion count = var.enable_db ? 1 : 0 del recurso
      aws_db_instance. El patron de count condicional es correcto para controlar
      si el recurso existe. El problema es que prevent_destroy = true impide
      que count = 0 funcione. La solucion es quitar prevent_destroy, no el count.

  - type: intention
    errorMessage: "La variable enable_db debe seguir existiendo."
    check:
      match: "variable\\s+\"enable_db\"\\s*\\{"
    failMessage: |
      No elimines la variable enable_db. Es parte del diseno de la configuracion
      y se usa para controlar condicionalmente la creacion de la base de datos.

terminalCommands:
  "terraform init":
    - output: |
        Initializing the backend...

        Initializing provider plugins...
        - Finding hashicorp/aws versions matching ">= 5.0"...
        - Installing hashicorp/aws v5.82.2...
        - Installed hashicorp/aws v5.82.2 (signed by HashiCorp)

        Terraform has created a lock file .terraform.lock.hcl to record the provider
        selections it made above. Include this file in your version control repository
        so that Terraform can guarantee to make the same selections by default when
        you run "terraform init" in the future.

        Terraform has been successfully initialized!
      exitCode: 0

  "terraform validate":
    - output: |
        Success! The configuration is valid.

        Note: Validation checks syntax and internal consistency only. It does not
        detect lifecycle conflicts that occur during plan/apply.
      exitCode: 0

  "terraform plan":
    - when:
        custom: |
          const dbBlock = code.match(/resource\s+"aws_db_instance"\s+"main"\s*\{([\s\S]*?)^\}/m);
          if (dbBlock && /prevent_destroy\s*=\s*true/.test(dbBlock[1])) {
            return { passed: true };
          }
          return { passed: false };
      output: |
        Terraform used the selected providers to generate the following execution plan.
        Resource actions are indicated with the following symbols:
          + create

        Terraform will perform the following actions:

          # aws_instance.app will be created
          + resource "aws_instance" "app" {
              + ami                                  = "ami-0c55b159cbfafe1f0"
              + arn                                  = (known after apply)
              + associate_public_ip_address          = (known after apply)
              + availability_zone                    = (known after apply)
              + get_password_data                    = false
              + id                                   = (known after apply)
              + instance_state                       = (known after apply)
              + instance_type                        = "t2.micro"
              + monitoring                           = (known after apply)
              + primary_network_interface_id         = (known after apply)
              + private_dns                          = (known after apply)
              + private_ip                           = (known after apply)
              + public_dns                           = (known after apply)
              + public_ip                            = (known after apply)
              + secondary_private_ips                = (known after apply)
              + subnet_id                            = (known after apply)
              + tenancy                              = (known after apply)
              + vpc_security_group_ids               = (known after apply)
            }

        Error: Instance cannot be destroyed

          on main.tf line 22, in resource "aws_db_instance" "main":
          22:   resource "aws_db_instance" "main" {

        Resource aws_db_instance.main has lifecycle.prevent_destroy set, but the
        plan calls for this resource to be destroyed. To avoid this error and
        continue with the plan, either disable lifecycle.prevent_destroy or
        reduce the scope of the change so that aws_db_instance.main is no longer
        included in the list of resources to be destroyed.
      exitCode: 1

    - when:
        custom: |
          const appBlock = code.match(/resource\s+"aws_instance"\s+"app"\s*\{([\s\S]*?)^\}/m);
          if (appBlock && /create_before_destroy\s*=\s*false/.test(appBlock[1])) {
            return { passed: true };
          }
          return { passed: false };
      output: |
        Terraform used the selected providers to generate the following execution plan.
        Resource actions are indicated with the following symbols:
          + create

        Terraform will perform the following actions:

          # aws_instance.app will be created
          + resource "aws_instance" "app" {
              + ami                                  = "ami-0c55b159cbfafe1f0"
              + arn                                  = (known after apply)
              + associate_public_ip_address          = (known after apply)
              + availability_zone                    = (known after apply)
              + get_password_data                    = false
              + id                                   = (known after apply)
              + instance_state                       = (known after apply)
              + instance_type                        = "t2.micro"
              + monitoring                           = (known after apply)
              + primary_network_interface_id         = (known after apply)
              + private_dns                          = (known after apply)
              + private_ip                           = (known after apply)
              + public_dns                           = (known after apply)
              + public_ip                            = (known after apply)
              + secondary_private_ips                = (known after apply)
              + subnet_id                            = (known after apply)
              + tenancy                              = (known after apply)
              + vpc_security_group_ids               = (known after apply)
            }

        Plan: 1 to add, 0 to change, 0 to destroy.

        Warning: create_before_destroy = false on aws_instance.app

        When this resource is replaced, the existing instance will be destroyed
        before the new one is created, causing service interruption. Consider
        setting create_before_destroy = true for zero-downtime deployments.
      exitCode: 0

    - output: |
        Terraform used the selected providers to generate the following execution plan.
        Resource actions are indicated with the following symbols:
          + create

        Terraform will perform the following actions:

          # aws_instance.app will be created
          + resource "aws_instance" "app" {
              + ami                                  = "ami-0c55b159cbfafe1f0"
              + arn                                  = (known after apply)
              + associate_public_ip_address          = (known after apply)
              + availability_zone                    = (known after apply)
              + get_password_data                    = false
              + id                                   = (known after apply)
              + instance_state                       = (known after apply)
              + instance_type                        = "t2.micro"
              + monitoring                           = (known after apply)
              + primary_network_interface_id         = (known after apply)
              + private_dns                          = (known after apply)
              + private_ip                           = (known after apply)
              + public_dns                           = (known after apply)
              + public_ip                            = (known after apply)
              + secondary_private_ips                = (known after apply)
              + subnet_id                            = (known after apply)
              + tenancy                              = (known after apply)
              + vpc_security_group_ids               = (known after apply)
            }

        Plan: 1 to add, 0 to change, 0 to destroy.
      exitCode: 0
