id: "k8s-08-secret-plaintext"
title: "Secret en texto plano"
briefing: "Este Secret usa el campo data pero los valores no están codificados en base64. El API server rechaza los datos. Corrige la codificación o usa una alternativa."
prerequisites: []
language: "yaml"
initialCode: |
  apiVersion: v1
  kind: Secret
  metadata:
    name: db-credentials
  type: Opaque
  data:
    username: admin
    password: mypassword

hints:
  - "El error dice 'illegal base64 data'. El campo data espera valores codificados en base64, no texto plano."
  - "Tienes dos opciones: codificar los valores en base64 (echo -n 'admin' | base64 da YWRtaW4=), o usar stringData en lugar de data."
  - "Solución más sencilla: cambia \"data:\" por \"stringData:\" y deja los valores en texto plano. Kubernetes los codificará automáticamente."
successMessage: |
  ¡Bien! El Secret ahora se crea correctamente.

  Lo que aprendiste:
  - El campo "data" requiere valores codificados en base64
  - El campo "stringData" acepta valores en texto plano y Kubernetes los codifica
  - base64 NO es cifrado — es solo una codificación. Los Secrets se almacenan en etcd
  - Para cifrado real, necesitas EncryptionConfiguration o herramientas como Sealed Secrets
  - Puedes codificar con: echo -n "valor" | base64
  - Y decodificar con: echo "dmFsb3I=" | base64 --decode

i18n:
  en:
    title: "Secret in plaintext"
    briefing: "This Secret uses the data field but the values are not base64 encoded. The API server rejects the data. Fix the encoding or use an alternative."
    hints:
      - "The error says 'illegal base64 data'. The data field expects base64 encoded values, not plaintext."
      - "You have two options: encode the values in base64 (echo -n 'admin' | base64 gives YWRtaW4=), or use stringData instead of data."
      - "Easier solution: change \"data:\" to \"stringData:\" and leave the values in plaintext. Kubernetes will encode them automatically."
    successMessage: |
      Good! The Secret now creates correctly.

      What you learned:
      - The "data" field requires base64 encoded values
      - The "stringData" field accepts plaintext values and Kubernetes encodes them
      - base64 is NOT encryption — it's just encoding. Secrets are stored in etcd
      - For real encryption, you need EncryptionConfiguration or tools like Sealed Secrets
      - You can encode with: echo -n "value" | base64
      - And decode with: echo "dmFsb3I=" | base64 --decode

validations:
  - type: syntax
    errorMessage: "El YAML debe ser válido."
    check:
      custom: |
        try {
          yaml.load(code);
          return { passed: true };
        } catch (e) {
          return {
            passed: false,
            errorMessage: "Error: YAML parse error\n\n" + (e instanceof Error ? e.message : "YAML inválido")
          };
        }
    failMessage: "Error: YAML parse error."

  - type: semantic
    errorMessage: "El Secret debe tener datos definidos (data o stringData)."
    check:
      custom: |
        try {
          const parsed = yaml.load(code);
          if (!parsed) return { passed: true };
          if (!("data" in parsed) && !("stringData" in parsed)) {
            return {
              passed: false,
              errorMessage: "Error: el Secret no tiene datos definidos\n\nUn Secret necesita al menos un campo data o stringData con los valores secretos."
            };
          }
          return { passed: true };
        } catch { return { passed: true }; }
    failMessage: "El Secret debe tener datos definidos."

  - type: intention
    errorMessage: "Los valores en data deben estar en base64, o usa stringData para texto plano."
    check:
      custom: |
        try {
          const parsed = yaml.load(code);
          if (!parsed) return { passed: true };
          if ("stringData" in parsed) return { passed: true };
          if (!("data" in parsed)) return { passed: true };
          const data = parsed.data;
          if (typeof data !== 'object' || data === null) return { passed: true };
          const isBase64 = function(value) {
            const pattern = /^[A-Za-z0-9+/]+=*$/;
            return pattern.test(String(value)) && String(value).length > 0;
          };
          for (const key in data) {
            const value = String(data[key]);
            if (!isBase64(value)) {
              return {
                passed: false,
                errorMessage: "Error: illegal base64 data\n\nCuando usas el campo data en un Secret, los valores deben estar codificados en base64.\nTienes dos opciones:\n1. Usar \"stringData\" en lugar de \"data\" — Kubernetes codifica los valores automáticamente\n2. Codificar los valores manualmente con: echo -n \"mi-valor\" | base64"
              };
            }
          }
          return { passed: true };
        } catch { return { passed: true }; }
    failMessage: "Los valores en data deben estar en base64."

terminalCommands:
  "kubectl apply -f secret.yaml":
    - when:
        custom: |
          try { yaml.load(code); return false; } catch { return true; }
      output: |
        error: error validating "secret.yaml": error converting YAML to JSON: yaml: invalid YAML
      exitCode: 1
    - when:
        custom: |
          try {
            const p = yaml.load(code);
            if (!p || "stringData" in p || !("data" in p)) return false;
            const data = p.data;
            if (typeof data !== 'object' || data === null) return false;
            const isBase64 = function(v) {
              const pattern = /^[A-Za-z0-9+/]+=*$/;
              return pattern.test(String(v)) && String(v).length > 0;
            };
            for (const key in data) {
              if (!isBase64(data[key])) return true;
            }
            return false;
          } catch { return false; }
      output: |
        Error from server (Invalid): error when creating "secret.yaml": Secret "db-credentials" is invalid:
        data[username]: Invalid value: illegal base64 data at input byte 2
      exitCode: 1
    - output: "secret/db-credentials created"
      exitCode: 0

  "kubectl get secrets":
    - when:
        custom: |
          try {
            const p = yaml.load(code);
            if (!p) return false;
            if ("stringData" in p) return true;
            if (!("data" in p)) return false;
            const data = p.data;
            if (typeof data !== 'object' || data === null) return false;
            const isBase64 = function(v) {
              const pattern = /^[A-Za-z0-9+/]+=*$/;
              return pattern.test(String(v)) && String(v).length > 0;
            };
            for (const key in data) {
              if (!isBase64(data[key])) return false;
            }
            return true;
          } catch { return false; }
      output: |
        NAME              TYPE     DATA   AGE
        db-credentials    Opaque   2      5s
      exitCode: 0
    - output: "No resources found in default namespace."
      exitCode: 0

  "kubectl describe secret db-credentials":
    - when:
        custom: |
          try {
            const p = yaml.load(code);
            if (!p) return false;
            if ("stringData" in p) return true;
            if (!("data" in p)) return false;
            const data = p.data;
            if (typeof data !== 'object' || data === null) return false;
            const isBase64 = function(v) {
              const pattern = /^[A-Za-z0-9+/]+=*$/;
              return pattern.test(String(v)) && String(v).length > 0;
            };
            for (const key in data) {
              if (!isBase64(data[key])) return false;
            }
            return true;
          } catch { return false; }
      output: |
        Name:         db-credentials
        Namespace:    default
        Labels:       <none>
        Annotations:  <none>

        Type:  Opaque

        Data
        ====
          username:  5 bytes
          password:  10 bytes
      exitCode: 0
    - output: "Error from server (NotFound): secrets \"db-credentials\" not found"
      exitCode: 1
