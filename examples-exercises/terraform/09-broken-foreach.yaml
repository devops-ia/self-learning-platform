id: "tf-09-broken-foreach"
title: "for_each inválido"
briefing: "for_each = 3 no es válido. A diferencia de count, for_each necesita un map o set. Corrige el argumento."
prerequisites: []
language: "hcl"
initialCode: |
  terraform {
    required_providers {
      aws = {
        source  = "hashicorp/aws"
        version = ">= 5.0"
      }
    }
  }

  provider "aws" {
    region = "us-east-1"
  }

  resource "aws_iam_user" "users" {
    for_each = 3

    name = "user-${each.key}"
  }

hints:
  - "El error dice que for_each necesita un map o set de strings, no un número. ¿Qué estructura de datos puedes usar?"
  - "Puedes usar toset([\"alice\", \"bob\", \"carol\"]) para crear un set de strings, o un map con llaves descriptivas."
  - "Solución: cambia for_each = 3 por for_each = toset([\"alice\", \"bob\", \"carol\"]) y usa name = each.key."
successMessage: |
  ¡Correcto! for_each ahora usa un set válido.

  Lo que aprendiste:
  - for_each acepta maps y sets, nunca números ni listas directas
  - toset() convierte una lista en un set, que for_each sí acepta
  - each.key es la clave del elemento actual; each.value es el valor
  - for_each es más flexible que count porque cada instancia tiene una clave estable
  - Si eliminas un elemento del set, solo se destruye esa instancia (con count se reindexaría todo)

i18n:
  en:
    title: "Invalid for_each"
    briefing: "for_each = 3 is not valid. Unlike count, for_each needs a map or set. Fix the argument."
    hints:
      - "The error says for_each needs a map or set of strings, not a number. What data structure can you use?"
      - "You can use toset([\"alice\", \"bob\", \"carol\"]) to create a set of strings, or a map with descriptive keys."
      - "Solution: change for_each = 3 to for_each = toset([\"alice\", \"bob\", \"carol\"]) and use name = each.key."
    successMessage: |
      Correct! for_each now uses a valid set.

      What you learned:
      - for_each accepts maps and sets, never numbers or lists directly
      - toset() converts a list to a set, which for_each accepts
      - each.key is the key of the current element; each.value is the value
      - for_each is more flexible than count because each instance has a stable key
      - If you remove an element from the set, only that instance is destroyed (with count everything would be reindexed)

validations:
  - type: syntax
    errorMessage: "for_each no acepta valores numéricos."
    check:
      match: 'for_each\s*=\s*\d+'
    failMessage: |
      Error: for_each no acepta números

      for_each = 3 no es válido. A diferencia de count, for_each necesita
      un map o un set de strings para saber qué instancias crear.

  - type: semantic
    errorMessage: "for_each debe ser un map o set de strings."
    check:
      custom: |
        (code) => {
          const hasToset = code.includes("toset(");
          const hasMap = /for_each\s*=\s*\{/.test(code);
          const hasBracketSet = /for_each\s*=\s*toset/.test(code);
          const hasVariable = /for_each\s*=\s*var\./.test(code);

          if (!hasToset && !hasMap && !hasBracketSet && !hasVariable) {
            return {
              passed: false,
              errorMessage: `Error: for_each necesita un map o un set

        for_each acepta:
        - Un map: for_each = { alice = {...}, bob = {...} }
        - Un set: for_each = toset(["alice", "bob", "carol"])
        - Una variable de tipo map o set

        Cada elemento se convierte en una instancia del recurso con su propia clave.`
            };
          }
          return { passed: true };
        }
    failMessage: |
      Error: for_each necesita un map o un set de strings

      for_each acepta solo estructuras de datos tipo map o set, nunca valores
      numéricos ni listas directas.

      Opciones válidas:
      - Un map: for_each = { alice = "email1", bob = "email2" }
      - Un set: for_each = toset(["alice", "bob", "carol"])
      - Una variable: for_each = var.users (donde users es map o set)

      Cada elemento del map/set se convierte en una instancia del recurso con
      su propia clave estable. Usa each.key y each.value dentro del recurso
      para acceder a los valores.

  - type: intention
    errorMessage: "Usa each.key o each.value en los atributos del recurso."
    check:
      custom: |
        (code) => {
          const hasForEachFixed = !/for_each\s*=\s*\d+/.test(code);
          if (hasForEachFixed && !code.includes("each.")) {
            return {
              passed: false,
              errorMessage: `Warning: No usas each.key ni each.value

        Con for_each, cada instancia tiene acceso a each.key y each.value.
        Para que cada recurso sea distinto, usa each.key o each.value en los atributos.
        Por ejemplo: name = each.key o name = each.value.`
            };
          }
          return { passed: true };
        }
    failMessage: |
      Warning: No usas each.key ni each.value en el recurso

      Con for_each, cada instancia del recurso tiene acceso a each.key (la clave
      del map/set) y each.value (el valor correspondiente).

      Para que cada recurso sea diferente, usa estas variables en los atributos:
        - name = each.key (usa la clave como nombre)
        - name = each.value (usa el valor como nombre)
        - tags = { Name = each.key } (usa la clave en tags)

      Si no usas each.key o each.value, todas las instancias serán idénticas,
      lo cual normalmente causará errores (nombres duplicados, etc.).

terminalCommands:
  "terraform init":
    - output: |
        Initializing the backend...

        Initializing provider plugins...
        - Finding hashicorp/aws versions matching ">= 5.0"...
        - Installing hashicorp/aws v5.31.0...
        - Installed hashicorp/aws v5.31.0 (signed by HashiCorp)

        Terraform has been successfully initialized!
      exitCode: 0

  "terraform plan":
    - when:
        match: 'for_each\s*=\s*\d+'
      output: |
        ╷
        │ Error: Invalid for_each argument
        │
          on main.tf line 14, in resource "aws_iam_user" "users":
          14:   for_each = 3
        │
        │ The given "for_each" argument value is unsuitable: the "for_each"
        │ argument must be a map, or set of strings, and you have provided a
        │ value of type number.
        ╵
      exitCode: 1
    - when:
        match: 'for_each\s*=\s*"'
      output: |
        ╷
        │ Error: Invalid for_each argument
        │
        │ The given "for_each" argument value is unsuitable: the "for_each"
        │ argument must be a map, or set of strings, and you have provided a
        │ value of type string.
        ╵
      exitCode: 1
    - when:
        custom: |
          (code) => {
            const hasToset = code.includes("toset(");
            const hasMap = /\{[^}]*=/.test(code) && /for_each/.test(code);
            return !hasToset && !hasMap && !/for_each\s*=\s*\[/.test(code);
          }
      output: |
        ╷
        │ Error: Invalid for_each argument
        │
        │ The given "for_each" argument value is unsuitable.
        ╵
      exitCode: 1
    - output: |
        Terraform used the selected providers to generate the following execution
        plan. Resource actions are indicated with the following symbols:
          + create

        Terraform will perform the following actions:

          # aws_iam_user.users["alice"] will be created
          + resource "aws_iam_user" "users" {
              + name = "alice"
            }

          # aws_iam_user.users["bob"] will be created
          + resource "aws_iam_user" "users" {
              + name = "bob"
            }

          # aws_iam_user.users["carol"] will be created
          + resource "aws_iam_user" "users" {
              + name = "carol"
            }

        Plan: 3 to add, 0 to change, 0 to destroy.
      exitCode: 0
